= PACS Support in Cumin
:toc:
:toclevels: 2
:sectnums:

== Overview

`cumin` is the infrastructure layer; its PACS helpers are deliberately minimal and silent. They wrap the ChRIS CUBE PACS endpoints, normalize responses into typed records, and surface failures through `Result<T>` plus `errorStack`. There is no console output here—callers decide how to present data. Think of this as the “plumbing” that higher layers use to issue queries, resolve servers, and decode payloads.

== Capabilities

=== PACS Server & Query Operations

- **List PACS servers**: `pacsServers_list(options?: PACSServerListOptions)` → `Result<PACSServer[]>`
- **Resolve PACS server**: `pacsServer_resolve(pacsserver: string)` → `Result<{ id: number; identifier?: string }>` (accepts id or identifier; errors on ambiguity)
- **List PACS queries**: `pacsQueries_list(options?: PACSQueryListOptions)` → `Result<FilteredResourceData | null>`
- **Create PACS query**: `pacsQueries_create(pacsserver: string, data: PACSQueryCreateData)` → `Result<PACSQueryRecord>`
- **Decode PACS query result**: `pacsQuery_resultDecode(queryId: number)` → `Result<PACSQueryDecodedResult>`

=== PACS Retrieve Operations

- **Create PACS retrieve**: `pacsRetrieve_create(queryId: number)` → `Result<PACSRetrieveRecord>` (triggers external service to pull DICOM data from PACS to ChRIS)
- **List PACS retrieves**: `pacsRetrieves_list(queryId: number, options?: ListOptions)` → `Result<PACSRetrieveRecord[]>` (get all retrieves for a query)
- **Delete PACS retrieve**: `pacsRetrieve_delete(retrieveId: number)` → `Result<void>` (cancel an in-progress retrieve)
- **Generate status report**: `pacsRetrieve_statusForQuery(queryId: number)` → `Result<PACSQueryStatusReport>` (combines query decode with file counts to show series-level progress)

== Data Shapes

=== Query-Related Types

- `PACSServer`: `{ id: number; identifier?: string; name?: string; description?: string; ... }`
- `PACSServerListOptions`: `{ identifier?: string; limit?: number; offset?: number; ... }`
- `PACSQueryListOptions`: standard list options plus `pacs_id?`, `pacs_identifier?`
- `PACSQueryCreateData`: `{ title: string; query: string; description?: string }` (query is JSON string of DICOM tag filters)
- `PACSQueryRecord`: `{ id: number; title?: string; status?: string; pacs_id?: number; result?: unknown; ... }`
- `PACSQueryDecodedResult`: `{ raw: string; base64Decoded?; zlibDecoded?; gzipDecoded?; text?; json? }`

=== Retrieve-Related Types

- `PACSRetrieveRecord`: `{ id: number; pacs_query_id?: number; status?: string; creation_date?: string; ... }`
  - Status values: `"created"` (initial), `"sent"` (in progress), `"succeeded"` (complete), `"errored"` (failed)
- `SeriesRetrieveStatus`: `{ seriesInfo: Record; seriesInstanceUID: string; seriesDescription?: string; expectedFiles: number; actualFiles: number; status: "pending" | "pulling" | "pulled" | "error" }`
- `StudyRetrieveStatus`: `{ studyInfo: Record; studyInstanceUID?: string; studyDescription?: string; series: SeriesRetrieveStatus[] }`
- `PACSQueryStatusReport`: `{ queryId: number; retrieveStatus?: string; retrieveId?: number; studies: StudyRetrieveStatus[] }`

== Behaviors and Guarantees

=== General

- All functions require an active CUBE connection; otherwise they return `Err()` and push a descriptive error.
- Server resolution is explicit: numeric strings become IDs; identifiers are looked up with ambiguity checks.
- Query creation leaves the raw PACS query string untouched—callers must supply JSON/DICOM tag filters.
- Result decoding is best-effort: base64 → zlib/gzip → UTF-8 → JSON. Failures stay silent except for `errorStack`.
- No logging is performed; the calling layer owns presentation.

=== Retrieve-Specific

- `pacsRetrieve_create()` triggers an external service to pull DICOM data from PACS to ChRIS; the retrieve happens asynchronously.
- `pacsRetrieves_list()` returns all retrieve records for a query, ordered by creation date.
- `pacsRetrieve_delete()` cancels a retrieve; partially-pulled data may remain in ChRIS.
- `pacsRetrieve_statusForQuery()` performs complex correlation:
  - Decodes query result to get expected series and file counts
  - Queries PACSSeries by SeriesInstanceUID to find folder paths
  - Counts PACSFiles in each folder to determine actual file counts
  - Computes status: `pending` (0 files), `pulling` (partial), `pulled` (complete), `error` (count mismatch)
- DICOM tag objects `{label, value}` are automatically extracted to their primitive values.

== Usage Patterns

=== Basic Query Workflow

```typescript
import type {
  Result,
  PACSServer,
  PACSQueryRecord,
  PACSQueryDecodedResult,
} from "@fnndsc/cumin";
import {
  pacsServers_list,
  pacsServer_resolve,
  pacsQueries_create,
  pacsQuery_resultDecode,
} from "@fnndsc/cumin";

const serversResult: Result<PACSServer[]> = await pacsServers_list();
if (serversResult.ok) {
  const servers: PACSServer[] = serversResult.value;
  console.log(servers);
}

const resolved = await pacsServer_resolve("PACSDCM");
if (!resolved.ok) return;
const resolvedServerId: number = resolved.value.id;

const createdQuery: Result<PACSQueryRecord> = await pacsQueries_create("PACSDCM", {
  title: "PID 4456554",
  query: JSON.stringify({ PatientID: "4456554" }),
});
if (!createdQuery.ok) return;
const queryId: number = createdQuery.value.id;

const decodedResult: Result<PACSQueryDecodedResult> = await pacsQuery_resultDecode(
  queryId
);
if (decodedResult.ok && decodedResult.value.json) {
  const decodedJson: unknown = decodedResult.value.json;
  console.log(decodedJson);
}
```

=== Retrieve Workflow with Progress Monitoring

```typescript
import type {
  Result,
  PACSRetrieveRecord,
  PACSQueryStatusReport,
} from "@fnndsc/cumin";
import {
  pacsRetrieve_create,
  pacsRetrieve_statusForQuery,
  pacsRetrieves_list,
} from "@fnndsc/cumin";

const queryId: number = 123; // an existing PACS query id

// Trigger retrieve
const retrieveResult: Result<PACSRetrieveRecord> = await pacsRetrieve_create(queryId);
if (!retrieveResult.ok) return;
const retrieveId: number = retrieveResult.value.id;

console.log(`Created retrieve ${retrieveId}`);

// Check status
const statusResult: Result<PACSQueryStatusReport> = await pacsRetrieve_statusForQuery(
  queryId
);
if (statusResult.ok) {
  const statusReport: PACSQueryStatusReport = statusResult.value;
  for (const study of statusReport.studies) {
    for (const series of study.series) {
      console.log(`${series.seriesDescription}: ${series.status} (${series.actualFiles}/${series.expectedFiles})`);
    }
  }
}

// List all retrieves for this query
const retrievesResult: Result<PACSRetrieveRecord[]> = await pacsRetrieves_list(queryId);
if (retrievesResult.ok) {
  const retrieves: PACSRetrieveRecord[] = retrievesResult.value;
  console.log(`Found ${retrieves.length} retrieves`);
}
```
