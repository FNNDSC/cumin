= ListCache: Directory Listing Cache
:toc:
:toc-placement: preamble
:toclevels: 3
:sectnums:

== Overview

The `ListCache` is a singleton that provides a generic caching layer for directory listings and other data structures. It was designed to eliminate redundant API calls during operations like tab completion and wildcard expansion, significantly improving shell performance.

=== The Problem

In an interactive shell environment, certain operations trigger multiple identical API calls:

* **Tab completion**: Each keystroke may query the same directory
* **Wildcard expansion**: `ls *.txt` must list the directory to match patterns
* **Sequential commands**: `ls` followed by `cd` both need the same directory data

Without caching, a simple wildcard like `ls *rudolph*` in a directory with 100+ files would:

1. Fetch the directory listing (200ms API call)
2. Filter matches locally
3. Repeat for the next operation

This created noticeable lag and unnecessary server load.

=== The Solution

`ListCache` provides:

1. **Generic caching**: Store any data type, not just listings
2. **Path-based keys**: Natural mapping to filesystem operations
3. **Automatic invalidation**: Cache clears when CWD changes
4. **Statistics tracking**: Monitor hit/miss rates for optimization

[source,typescript]
----
import { listCache_get } from '@fnndsc/cumin';

const listCache = listCache_get();

// Store data
listCache.cache_set('/home/user/data', directoryItems);

// Retrieve data
const cached = listCache.cache_get('/home/user/data');
if (cached) {
  // Use cached data (null = cache miss)
  return cached;
}

// Cache miss - fetch fresh data
const fresh = await fetchFromAPI();
listCache.cache_set('/home/user/data', fresh);
----

== Architecture

=== Singleton Pattern

`ListCache` uses the singleton pattern to ensure all parts of the application share the same cache:

[source,typescript]
----
class ListCache {
  private static instance: ListCache;

  static instance_get(): ListCache {
    if (!ListCache.instance) {
      ListCache.instance = new ListCache();
    }
    return ListCache.instance;
  }
}

// Convenience function
export function listCache_get(): ListCache {
  return ListCache.instance_get();
}
----

This ensures that:

* Cache is shared across all modules
* No duplicate cache instances
* Consistent state throughout application lifecycle

=== Generic Storage

Unlike specialized caches, `ListCache` stores `any` type:

[source,typescript]
----
private cache: Map<string, any> = new Map();

cache_set(path: string, data: any): void {
  this.cache.set(path, data);
  this.stats.sets++;
}

cache_get(path: string): any | null {
  if (this.cache.has(path)) {
    this.stats.hits++;
    return this.cache.get(path);
  }
  this.stats.misses++;
  return null;
}
----

**Why `any` instead of generic `T`?**

* Simplifies caller code (no type parameters needed)
* Cache stores heterogeneous data (listings, plugin data, etc.)
* Callers know what type they stored - no runtime confusion

**Why return `null` instead of `Result<T>`?**

* Cache miss is a **normal state**, not an error
* `null` is semantically clearer: "no data here"
* `Result<T>` is for operations that can fail (API calls, validation)

[quote]
____
*Design principle:* Use `null` for absence of data, `Result<T>` for operations that can fail with errors.
____

=== Automatic Invalidation

The cache hooks into cumin's `chrisContext` to automatically clear when the CWD changes:

[source,typescript]
----
// In chrisContext.ts
async current_set(context: Context, value: string): Promise<boolean> {
  case Context.ChRISfolder:
    this._singleContext.folder = value;
    status = await this.ChRISfolder_set(value);

    // Invalidate cache on CWD change
    const listCache = listCache_get();
    listCache.cwd_update(value);
    break;
}

// In listCache.ts
cwd_update(newCwd: string): void {
  if (newCwd !== this.currentCwd) {
    this.cache_invalidate(); // Clear entire cache
    this.currentCwd = newCwd;
  }
}
----

**Why clear the entire cache on CWD change?**

* Simple and predictable behavior
* Avoids stale data from relative path operations
* Memory usage stays bounded
* Callers will repopulate with fresh data

Users can also manually invalidate:

[source,typescript]
----
// Invalidate specific path
listCache.cache_invalidate('/home/user/data');

// Invalidate entire cache
listCache.cache_invalidate();
----

== API Reference

=== Core Methods

==== `cache_set(path: string, data: any): void`

Stores data at the given path key.

[source,typescript]
----
const items: ListingItem[] = await files_list({}, '/home/user');
listCache.cache_set('/home/user', items);
----

**Parameters:**
[cols="1,3"]
|===
|`path` |Cache key (typically a filesystem path)
|`data` |Data to store (any type)
|===

==== `cache_get(path: string): any \| null`

Retrieves data from the cache.

[source,typescript]
----
const cached = listCache.cache_get('/home/user');
if (cached) {
  // Use cached data
} else {
  // Fetch fresh data
}
----

**Returns:**
[cols="1,3"]
|===
|`any` |Cached data if found
|`null` |Cache miss (no data at this path)
|===

==== `cwd_update(newCwd: string): void`

Updates current working directory and invalidates cache if changed.

[source,typescript]
----
// Called automatically by chrisContext
listCache.cwd_update('/home/newuser');
----

**Behavior:**

* If `newCwd` differs from current: clears cache
* If `newCwd` same as current: no-op

==== `cache_invalidate(path?: string): void`

Invalidates cache entries.

[source,typescript]
----
// Invalidate specific path
listCache.cache_invalidate('/home/user');

// Invalidate entire cache
listCache.cache_invalidate();
----

**Parameters:**
[cols="1,3"]
|===
|`path` (optional) |Path to invalidate. If omitted, clears entire cache.
|===

=== Statistics

==== `stats_get(): CacheStats`

Returns cache performance statistics.

[source,typescript]
----
const stats = listCache.stats_get();
console.log(`Hit rate: ${stats.hits}/${stats.hits + stats.misses}`);
----

**Returns:**
[source,typescript]
----
interface CacheStats {
  hits: number;    // Successful cache retrievals
  misses: number;  // Cache misses
  sets: number;    // Items stored
}
----

==== `stats_reset(): void`

Resets statistics to zero.

[source,typescript]
----
listCache.stats_reset();
----

== Usage Patterns

=== Pattern 1: Check-Then-Fetch

The most common pattern for using the cache:

[source,typescript]
----
async function getDirectoryData(path: string): Promise<ListingItem[]> {
  const listCache = listCache_get();

  // Check cache first
  const cached: ListingItem[] | null = listCache.cache_get(path);
  if (cached) {
    return cached;
  }

  // Cache miss - fetch from API
  const fresh: ListingItem[] = await files_list({}, path);

  // Store for next time
  listCache.cache_set(path, fresh);

  return fresh;
}
----

=== Pattern 2: Wildcard Expansion with Cache

Wildcard operations benefit significantly from caching:

[source,typescript]
----
async function wildcard_expand(pattern: string): Promise<Result<string[]>> {
  const cwd: string = await session.getCWD();
  const listCache = listCache_get();

  // Check cache for directory listing
  let items: ListingItem[] | null = listCache.cache_get(cwd);
  if (!items) {
    // Fetch and cache
    items = await files_list({}, cwd);
    listCache.cache_set(cwd, items);
  }

  // Filter matches locally
  const matches: string[] = items
    .filter((item: ListingItem) => minimatch(item.name, pattern))
    .map((item: ListingItem) => item.name);

  return Ok(matches);
}
----

**Performance improvement:**

* First `ls *.txt`: 200ms (cache miss + API call)
* Second `ls *.js` in same dir: 5ms (cache hit + local filter)
* **40x faster** for subsequent operations

=== Pattern 3: Virtual Directory Caching

Cache virtual directories (like `/bin`) alongside native paths:

[source,typescript]
----
async function getVirtualBinItems(): Promise<ListingItem[]> {
  const listCache = listCache_get();

  // Check cache
  const cached: ListingItem[] | null = listCache.cache_get('/bin');
  if (cached) {
    return cached;
  }

  // Fetch plugins from API
  const plugins = await plugins_listAll({});
  const items: ListingItem[] = /* transform plugins to ListingItems */;

  // Cache for tab completion and ls
  listCache.cache_set('/bin', items);

  return items;
}
----

=== Pattern 4: Prefetching for Tab Completion

Populate cache proactively during navigation:

[source,typescript]
----
async function changeDirectory(path: string): Promise<void> {
  await session.setCWD(path); // Triggers cache invalidation

  // Prefetch new directory for immediate tab completion
  const listCache = listCache_get();
  const items: ListingItem[] = await files_list({}, path);
  listCache.cache_set(path, items);
}
----

== Integration

=== Module Structure

[source]
----
cumin/
├── src/
│   ├── cache/
│   │   ├── listCache.ts      # Implementation
│   │   └── index.ts          # Exports
│   ├── context/
│   │   └── chrisContext.ts   # Auto-invalidation hook
│   └── index.ts              # Re-exports ListCache
└── docs/
    └── listcache.adoc        # This document
----

=== Imports

[source,typescript]
----
// In cumin (internal)
import { listCache_get } from '../cache/index.js';

// In other packages (external)
import { listCache_get } from '@fnndsc/cumin';
----

=== Usage Across Packages

==== cumin

* Defines and exports `ListCache`
* Hooks invalidation into `chrisContext`

==== chell

* Uses cache for wildcard expansion (`wildcard.ts`)
* Uses cache for VFS operations (`vfs.ts`)
* Benefits from automatic invalidation on `cd`

==== chili

* Can use cache for command implementations
* Particularly useful for operations that list directories multiple times

==== Future: Web UI

* Same cache instance shared across UI components
* Consistent data without prop drilling
* Automatic invalidation on navigation

== Performance Characteristics

=== Time Complexity

[cols="2,1,3"]
|===
|Operation |Complexity |Notes

|`cache_get()`
|O(1)
|Map lookup

|`cache_set()`
|O(1)
|Map insertion

|`cache_invalidate(path)`
|O(1)
|Map deletion

|`cache_invalidate()`
|O(n)
|Clear all entries

|`cwd_update()`
|O(1) or O(n)
|O(1) if same CWD, O(n) if changed
|===

=== Space Complexity

* **Per entry**: ~500 bytes - 5KB depending on directory size
* **Typical shell session**: 10-50 cached directories
* **Max memory**: ~500KB for heavy usage
* **Bounded**: Auto-clears on CWD change

=== Real-World Performance

Measured in chell during typical usage:

[cols="2,2,2,3"]
|===
|Operation |Without Cache |With Cache |Improvement

|`ls *pattern*`
|180-250ms
|3-8ms
|**30-50x faster**

|Tab completion
|150-200ms
|5-10ms
|**20-30x faster**

|Wildcard in loop
|N × 200ms
|200ms + N × 5ms
|**Linear → constant + linear**

|Sequential ls
|400ms (2 calls)
|205ms (1 call + cache)
|**2x faster**
|===

== Design Decisions

=== Why Not Time-Based Expiration?

Cumin uses **event-based invalidation** (CWD change) instead of time-based (TTL):

**Pros of event-based:**

* Cache stays fresh during long operations in same directory
* No stale data after navigation
* No background timers or memory leaks
* Simpler mental model

**Cons of event-based:**

* Doesn't handle external changes (another user modifying directory)
* Manual invalidation needed for create/delete operations

**Verdict:** Event-based fits shell use case better. External changes are rare in single-user ChRIS workflows.

=== Why Singleton Instead of Dependency Injection?

**Singleton pros:**

* Simpler API: `listCache_get()` instead of passing around instance
* Guaranteed single cache across all modules
* Consistent with cumin's other singletons (`errorStack`, `chrisContext`)

**Singleton cons:**

* Harder to test with isolated cache instances
* Global state (but cache is inherently global)

**Verdict:** Singleton matches cumin's architecture and shell use case. For testing, use `stats_reset()` and `cache_invalidate()` to clean state.

=== Why Generic `any` Instead of Typed Cache?

**`any` pros:**

* No type parameters needed: `listCache_get()` not `listCache_get<ListingItem[]>()`
* Supports heterogeneous data (listings, plugins, feeds)
* Callers know their data types (no runtime confusion)

**`any` cons:**

* Loses compile-time type safety
* Caller must cast or trust their own code

**Verdict:** Pragmatic trade-off. The cache is a dumb store - callers are responsible for data types. Similar to `Map<string, any>` or `localStorage`.

=== Why `null` Instead of `Result<T>`?

See <<Generic Storage>> for detailed reasoning. Summary:

* Cache miss is normal, not an error
* `null` is clearer than `{ ok: false }`
* Keeps API simple: `if (cached)` not `if (result.ok)`

== Testing

=== Unit Tests

[source,typescript]
----
import { listCache_get } from '@fnndsc/cumin';

describe('ListCache', () => {
  let listCache: ListCache;

  beforeEach(() => {
    listCache = listCache_get();
    listCache.cache_invalidate(); // Clean slate
    listCache.stats_reset();
  });

  it('should return null for cache miss', () => {
    const result = listCache.cache_get('/nonexistent');
    expect(result).toBeNull();
  });

  it('should return cached data for cache hit', () => {
    const data = [{ name: 'file.txt' }];
    listCache.cache_set('/path', data);

    const result = listCache.cache_get('/path');
    expect(result).toEqual(data);
  });

  it('should invalidate cache on CWD change', () => {
    listCache.cache_set('/old', [1, 2, 3]);
    listCache.cwd_update('/new');

    const result = listCache.cache_get('/old');
    expect(result).toBeNull();
  });

  it('should track statistics', () => {
    listCache.cache_set('/path', []);
    listCache.cache_get('/path'); // hit
    listCache.cache_get('/missing'); // miss

    const stats = listCache.stats_get();
    expect(stats.sets).toBe(1);
    expect(stats.hits).toBe(1);
    expect(stats.misses).toBe(1);
  });
});
----

=== Integration Tests

Test cache behavior across multiple operations:

[source,typescript]
----
describe('ListCache integration', () => {
  it('should cache wildcard expansion results', async () => {
    const listCache = listCache_get();
    listCache.stats_reset();

    // First expansion - cache miss
    await wildcard_expand('*.txt');
    expect(listCache.stats_get().misses).toBe(1);

    // Second expansion - cache hit
    await wildcard_expand('*.js');
    expect(listCache.stats_get().hits).toBe(1);
  });

  it('should invalidate on directory change', async () => {
    await session.setCWD('/home/user');
    await vfs.list(); // Populates cache

    await session.setCWD('/home/other');

    const cached = listCache_get().cache_get('/home/user');
    expect(cached).toBeNull(); // Invalidated
  });
});
----

== Future Enhancements

=== Considered but Not Implemented

==== LRU Eviction

* **Why not**: Cache is small (10-50 entries), auto-clears on CWD change
* **When needed**: Multi-gigabyte directory trees, long-running sessions without navigation

==== Partial Invalidation

* **Why not**: Complexity vs benefit. Wildcards already fast with current approach.
* **When needed**: Real-time collaboration where other users modify directories

==== Compression

* **Why not**: Data is small (~1KB per listing), JavaScript objects already efficient
* **When needed**: Caching thousands of large directories

==== Persistent Cache

* **Why not**: Shell sessions are ephemeral, disk I/O slower than API for small data
* **When needed**: Offline mode, very slow network connections

== Changelog

=== v0.5.0 (2025-12-02)

* **Added**: `ListCache` singleton with generic caching
* **Added**: Automatic invalidation on CWD change via `chrisContext`
* **Added**: Statistics tracking (`hits`, `misses`, `sets`)
* **Integrated**: Used in chell's wildcard expansion and VFS operations

== References

=== Related Documentation

* link:error_handling.adoc[Error Handling in Cumin] - Why cache uses `null` not `Result<T>`
* `../src/cache/listCache.ts` - Implementation
* `../src/context/chrisContext.ts` - Auto-invalidation hook

=== Related Files

* `cumin/src/cache/listCache.ts` - Core implementation
* `chell/src/builtins/wildcard.ts` - Wildcard expansion using cache
* `chell/src/lib/vfs/vfs.ts` - VFS operations using cache

---

_Last updated: 2025-12-02_
